```{r}
library(rashomontva)
library(collections)
library(tidyverse)
library(data.table)
```

```{r}
x <- new_RashomonSet(models = list("hi","hello","hey"),
                     losses = c(1,3,1.5),
                     num_pools = list(2,3,1),
                     profiles = list("h","g","q"),
                     pool_dictionaries = list("x","q","c"))

sort(x)

insert_model(x)

```
#todo add examples

```{r}
# M = 2
# R = c(3,4)

data <- data.frame(
  arm1 = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3),
  arm2 = c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 1, 2, 3, 1, 2, 3, 4, 2, 4, 1, 2, 4),
  value = runif(27)
)
sigma <- initialize_sigma(2, c(5, 5))

data <- assign_policy_label(data, arm1, arm2)

data$original_label <- data$policy_label + 1

policy_list <- create_policies_from_data(data, arm1, arm2)

edge_list <- lattice_edges(sigma, policy_list)

M <- policy_means(data, value)

dict <- extract_pools(policy_list, sigma, lattice_edges = edge_list)

pools_to_data(data, dict)
# use as.integer

generate_policy_dict <- function(policy_list, sigma, lattice_edges, M){
  
  pool_dict <- extract_pools(policy_list, sigma, lattice_edges)
  # assigning pools to policy means so that we can compute pool means
  M_pool <- pools_to_data(M, pool_dict)
  # dictionary of pool means of type cc:dictionary()
  fixed_pool_means_dict <- policy_to_pool_means(M_pool, mean, pool)

  fixed_pool_means_dict
}

cc <- generate_policy_dict(policy_list, sigma, edge_list, M)

rashomontva::compute_mse_loss(data, value, cc, original_label, 0)


data %>% 
  mutate(mean = mean(value)) %>% 
  summarize(mse = mean((value-mean)^2))


#last things to do: 

# add collections::dict()- think carefully about how I want this to work
# add predict function
# otherwise done!
```

```{r}

rset <- aggregate_rashomon_profiles(data,
  arm1,
  arm2,
  arm3,
  M = M,
  H = H,
  R = R,
  reg = lamb,
  value = observation,
  theta = theta
)

# TODO: Make predictions from this output
# TODO: Test
# TODO: Deal with ids in a smart way
#' @export
make_rashomon_objects <- function(rset) {
  rash_models <- list()
  for (x in rset[[1]]) {
    rashomon_i <- new_RashomonSet(
      models = list(),
      losses = numeric(),
      num_pools = list(),
      profiles = list(),
      pool_dictionaries = list()
    )
    for (i in 1:length(rset[[2]])) {
      model_i <- rset[[2]][[i]]$models[[x[[i]]]]
      loss_i <- rset[[2]][[i]]$losses[[x[[i]]]]
      pools_i <- rset[[2]][[i]]$pools[[x[[i]]]]
      profiles_i <- rset[[2]][[i]]$profiles[[x[[i]]]]

      rashomon_i = insert_model(rashomon_i, list(model_i), loss_i, pools_i, list(profiles_i), NA)
    }
    rash_models <- append(rash_models, list(rashomon_i))
  }
  rash_models
}

output <- make_rashomon_objects(rset)

#' @export
models <- make_rashomon_objects(rset)

compute_loss <- function(model) {
  sum(model$losses)
}
```

```{r}

library(profvis)
profvis({
data <- assign_universal_label(data, arm1, arm2, arm3)

rset <- aggregate_rashomon_profiles(data,
  arm1,
  arm2,
  arm3,
  M = M,
  H = H,
  R = R,
  reg = lamb,
  value = observation,
  theta = theta
)
  
})

data

rset <- aggregate_rashomon_profiles(data, 
                            value = "observation",
                            arm_cols = c("arm1","arm2","arm3"),
                            M = 3, 
                            H = Inf, 
                            R = c(4,3,3),
                            reg = 1, 
                            theta = Inf,
                            inactive = 0)

make_rashomon_objects(rset)
```

```{r}

data <- read.csv("data.csv")

M <- 4
R <- c(5, 5, 5,5)
H <- Inf
theta <- .025
lamb <- 1

group_cols = c("X1","X2","X3","X4")
data <- assign_universal_label(data, group_cols)


#ways to speedup
#convert base function to Rcpp
#for num_pools

rset <- aggregate_rashomon_profiles(data, 
                                    arm_cols = group_cols,
  M = M,
  H = H,
  R = R,
  reg = lamb,
  value = "observation",
  theta = theta
)

find_profile_lower_bound <- function(data, value) {

  # Calculate the number of rows
  n_k <- nrow(data)

  # Calculate the mean by policy_label and add it as a new column
  data[, mean := mean(get(value), na.rm = TRUE), by = policy_label]

  # Calculate the RMSE, then square it and multiply by n_k
  rmse_squared_nk <- (yardstick::rmse_vec(data[[value]], data$mean))^2 * n_k

  rmse_squared_nk
}


find_profile_lower_bound(data, "Y")

x <- make_rashomon_objects(rset)
end <- Sys.time()
print(end - begin)

#Extract all model losses

get_all_losses <- function(rset){
  
  num_models <- length(rset[[1]])
  num_prof <- length(rset[[2]])
  
  all_losses <- numeric(num_models)
  for(j in 1:num_models){
    loss_j = 0 
    for(i in 1:num_prof){
      index <- rset[[1]][[j]][[i]]
      loss_i = rset[[2]][[i]]$losses[[index]]
      loss_j = loss_j + loss_i
    }
    all_losses[j] = loss_j
  }
  
  all_losses
}

get_all_losses(rset)

rash_obj <- make_rashomon_objects(rset)

losses <- c()
for(model in rash_obj){
  losses <- c(losses, sum(model$losses))
}

losses

get_all_losses(rset)
```

```{r}
library(profvis)
profvis({
rset <- aggregate_rashomon_profiles(data, 
                                    arm_cols = c("arm1","arm2","arm3"),
  M = M,
  H = H,
  R = R,
  reg = lamb,
  value = "observation",
  theta = theta
)
})
```


# How to get predictions from RashomonSet when multiple profiles are present in data
```{r}
data <- read.csv("output.csv") %>%
  rename(
    arm1 = "X0",
    arm2 = "X1",
    arm3 = "X2",
    id = "X",
    observation = "Y"
  ) %>%
  select(-D)



group_cols = c("arm1","arm2","arm3")
data <- assign_universal_label(data, group_cols)

M <- 3
R <- c(4, 3, 3)
H <- Inf
theta <- 13
lamb <- 1


rset <- aggregate_rashomon_profiles(data, 
                                    arm_cols = group_cols,
  M = M,
  H = H,
  R = R,
  reg = lamb,
  value = "observation",
  theta = theta
)


objs <- make_rashomon_objects(rset)

predictions <- predict(objs[[1]], data$universal_label, model_id = 1)

```


# How to get predictions from Rashomon Set for one profile
```{r}

data <- read.csv("data.csv")

# Setting parameters
M <- 4
R <- c(5, 5, 5,5)
H <- Inf
theta <- 3
lamb <- 1

#Setting names of things and profiles
arm_cols <- c("X1","X2","X3","X4")
value <- "Y"
profile <- c(1,1,1,1)

#Readying data, computing means and policies
data <- assign_universal_label(data, arm_cols)
data <- assign_policy_label(data, arm_cols)
policies <- rashomontva::create_policies_from_data(data, arm_cols)
policy_means <- rashomontva::policy_means(data, value)

rset <- aggregate_rashomon_profiles(data, 
                                    arm_cols = arm_cols,
  M = M,
  H = H,
  R = R,
  reg = lamb,
  value = "Y",
  theta = theta
)

x <- make_rashomon_objects(rset)

predicts <- predict(x[[1]], data$universal_label)

#computing RashomonSet for profile where everything is active (entire data in this case)
rashomon_profile <- find_rashomon_profile(data,
                      value,
                      arm_cols,
                      M,
                      R,
                      H,
                      reg = lamb, 
                      profile,
                      policies,
                      policy_means,
                      normalize = 0, 
                      theta,
                      filtered = TRUE,
                      inactive = 0 )

#if you care about it being sorted so that lowest loss model is first

rashomon_profile <- sort_rashomon(rashomon_profile)

#get predictions for fifth model in RashomonSet for profile (1,1,1,1)

model_id <- 5
labels <- data$universal_label

predictions <- predict(rashomon_profile, labels, model_id)

#to get all predictions, just loop through all models (1:length(rashomon_profile$models))



```

```{r}
# testing

policies <- rashomontva::create_policies_from_data(data, arm_cols)
sigma <- initialize_sigma(M, R)
hasse_edges <- lattice_edges(sigma, policies)
```

